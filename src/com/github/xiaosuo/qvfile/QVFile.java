package com.github.xiaosuo.qvfile;

import java.io.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import android.os.Environment;

/**
 * 
 * Handle the media files generated by QVod.
 *
 */
public class QVFile implements Comparable<QVFile> {
	private static final String PATH = Environment.getExternalStorageDirectory() + File.separator + "p2pcache";
	// The file extension of a data file.
	private static final String SLICE_EXT = ".!mv";
	// The length of a data file.
	private static final long SLICE_SIZE = 10 * (1 << 20); // 10M 

	private String path;
	private String name;
	private long length;
	private boolean isCompleted;
	private int maxID;

	/**
	 * Get the file list.
	 * 
	 * @return the file list.
	 */
	public static QVFile[] listFiles() throws IOException {
		List<QVFile> files = new ArrayList<QVFile>();
		for (String fileName : (new File(PATH)).list())
			files.add(new QVFile(fileName));
		Collections.sort(files);
		return (QVFile[])files.toArray(new QVFile[0]);
	}

	/**
	 * Get the name of the file.
	 * 
	 * @return the name of the file.
	 */
	public String getName() {
		return name;
	}

	/**
	 * Get the length of the file.
	 * 
	 * @return the length of the file
	 */
	public long length() {
		return length;
	}

	/**
	 * Check if the file is completed.
	 * 
	 * @return true if the file is completed, otherwise return false.
	 */
	public boolean isCompleted() {
		return isCompleted;
	}
	
	/**
	 * Indicator of the copy progress.
	 */
	public interface ProgressIndicator {
		/**
		 * Update the progress.
		 * 
		 * @param percent has been copied.
		 */
		public void update(int percent);
	}

	/**
	 * Copy the file to a new location.
	 * 
	 * @param path The path of the new file.
	 */
	public void copy(String path, ProgressIndicator indicator) throws IOException {
		assert(isCompleted);
		byte[] buffer = new byte[4096];
		int len;
		long accumulate = 0;
		int percent = 0;
		OutputStream os = new BufferedOutputStream(new FileOutputStream(path));
		for (int id = 0; id <= maxID; id++) {
			InputStream is = new BufferedInputStream(new FileInputStream(sliceName(id)));
			while ((len = is.read(buffer)) > 0) {
				os.write(buffer, 0, len);
				accumulate += len;
				int percentNew = (int)(accumulate * 100 / length);
				if (percentNew != percent) {
					percent = percentNew;
					indicator.update(percent);
				}
			}
			is.close();
		}
		os.close();
	}

	/**
	 * Delete the file.
	 */
	public void delete() throws IOException {
		File dir = new File(path);
		for (File f : dir.listFiles())
			f.delete();
		dir.delete();
	}

	/**
	 * Private constructor.
	 * 
	 * @param path The path of the file directory.
	 */
	private QVFile(String filename) throws IOException {
		path = PATH + File.separator + filename;
		// Get the ids and name.
		List<Integer> ids = new ArrayList<Integer>();
		name = null;
		for (String sliceName : (new File(path)).list()) {
			assert(sliceName.endsWith(SLICE_EXT));
			sliceName = sliceName.substring(0, sliceName.length() - SLICE_EXT.length());
			int pos = sliceName.lastIndexOf('_');
			int id = Integer.parseInt(sliceName.substring(pos + 1));
			ids.add(id);
			sliceName = sliceName.substring(0, pos);
			if (name == null)
				name = sliceName;
			assert(name == sliceName);
		}
		// Check if the file is completed.
		Collections.sort(ids);
		int idExpected = 0;
		isCompleted = true;
		for (int id : ids) {
			if (id != idExpected) {
				isCompleted = false;
				break;
			}
			idExpected++;
		}
		maxID = idExpected - 1;
		length = 0;
		for (int id : ids) {
			File file = new File(sliceName(id));
			if (file.length() != SLICE_SIZE && id != maxID) {
				isCompleted = false;
				break;
			}
			length += file.length();
		}
	}
	
	/**
	 * Construct the slice name from an ID.
	 * 
	 * @param id the slice ID.
	 * @return the slice name.
	 */
	private String sliceName(int id) {
		return path + File.separator + name + "_" + id + SLICE_EXT;
	}

	@Override
	public int compareTo(QVFile file) {
		String anotherName = file.name;
		int length = Math.min(name.length(), anotherName.length());
		for (int i = 0; i < length; i++) {
			byte[] b, b2;
			try {
				b = name.substring(i, i + 1).getBytes("GBK");
				b2 = anotherName.substring(i, i + 1).getBytes("GBK");
			} catch (UnsupportedEncodingException e) {
				if (name.charAt(i) != anotherName.charAt(i))
					return name.charAt(i) - anotherName.charAt(i);
				continue;
			}
			int code = getLe(b);
			int code2 = getLe(b2);
			if (code != code2)
				return code - code2;
		}
		return name.length() - anotherName.length();
	}

	/**
	 * Get the interval value in little endian.
	 *
	 * @param bytes the array of bytes.
	 * @return the integer.
	 */
	private int getLe(byte[] bytes) {
		int retval = 0;
		for (byte b : bytes)
			retval = (retval << 8) | (b & 0xff);
		return retval;
	}
}
